<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NHL Playoff Elimination Tracker</title>
  <link rel="icon" href="data:;base64,iVBORw0KGgo="> <!-- Suppress favicon 404 -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone@7/babel.min.js"></script>
  <style>
    .team-logo { position: absolute; width: 60px; height: 60px; transition: opacity 0.5s; z-index: 10; }
    .team-logo img { width: 100%; height: 100%; object-fit: contain; }
    .error-message { color: red; text-align: center; margin-top: 1rem; }
    .loading-message { color: blue; text-align: center; margin-top: 1rem; }
    select { min-width: 150px; z-index: 1000; visibility: visible; }
    .controls { min-height: 40px; z-index: 1000; display: flex; gap: 8px; flex-wrap: wrap; }
    .team-container { position: relative; width: 1200px; height: 900px; margin: 0 auto; background-color: #f0f0f0; } /* Placeholder background */
  </style>
</head>
<body class="bg-gray-100 font-sans">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, Component } = React;

    class ErrorBoundary extends Component {
      state = { error: null };
      static getDerivedStateFromError(error) {
        return { error };
      }
      render() {
        if (this.state.error) {
          return <div className="error-message">Render error: {this.state.error.message}</div>;
        }
        return this.props.children;
      }
    }

    function App() {
      const [eliminationData, setEliminationData] = useState({});
      const [teamCoordinates, setTeamCoordinates] = useState({});
      const [selectedSeason, setSelectedSeason] = useState('');
      const [isAnimating, setIsAnimating] = useState(false);
      const [error, setError] = useState(null);
      const [isLoading, setIsLoading] = useState(true);
      const [currentElimOrder, setCurrentElimOrder] = useState(0);

      useEffect(() => {
        if (Object.keys(eliminationData).length > 0 && !selectedSeason) {
          console.log('Setting default season to 2025');
          setSelectedSeason('2025');
        }
      }, [eliminationData]);

      useEffect(() => {
        console.log('Starting fetch for data...');
        setIsLoading(true);
        Promise.all([
          fetch('data/NHLelimseq.json').catch(() => { throw new Error('Failed to fetch NHLelimseq.json'); }),
          fetch('data/team_coordinates.json').catch(() => { throw new Error('Failed to fetch team_coordinates.json'); })
        ])
          .then(([elimRes, coordRes]) => {
            console.log('Fetch response statuses:', elimRes.status, coordRes.status);
            if (!elimRes.ok) throw new Error(`Failed to fetch NHLelimseq.json: ${elimRes.status}`);
            if (!coordRes.ok) throw new Error(`Failed to fetch team_coordinates.json: ${coordRes.status}`);
            return Promise.all([elimRes.json(), coordRes.json()]);
          })
          .then(([elimData, coordData]) => {
            console.log('Data fetched successfully:', Object.keys(elimData).length, 'seasons,', Object.keys(coordData).length, 'teams');
            console.log('Sample season data (1967):', elimData['1967']);
            console.log('Seasons available:', Object.keys(elimData).sort((a, b) => b - a));
            console.log('Teams in coordinates:', Object.keys(coordData));
            setEliminationData(elimData);
            setTeamCoordinates(coordData);
            setError(null);
            setIsLoading(false);
          })
          .catch(error => {
            console.error('Error fetching data:', error);
            setError(error.message);
            setIsLoading(false);
          });
      }, []);

      const project = (lat, lon) => {
        const mapWidth = 1200;
        const mapHeight = 900;
        // North America: lat 25–55°N, lon –130 to –60°W
        const x = ((lon + 130) * (mapWidth / 70)); // –130 to –60°W
        const y = ((55 - lat) * (mapHeight / 30)); // 25–55°N
        console.log(`Projecting team at lat: ${lat}, lon: ${lon} to x: ${x}, y: ${y}`);
        return { x, y };
      };

      const handleSeasonChange = (e) => {
        console.log('Selected season:', e.target.value);
        setSelectedSeason(e.target.value);
        setIsAnimating(false);
        setCurrentElimOrder(0);
      };

      const startAnimation = () => {
        if (!selectedSeason || isAnimating) return;
        console.log('Starting animation for season:', selectedSeason);
        setIsAnimating(true);

        const teams = eliminationData[selectedSeason]
          ? eliminationData[selectedSeason].sort((a, b) => a['elim order'] - b['elim order'])
          : [];
        const maxElimOrder = teams.length ? Math.max(...teams.map(t => t['elim order'])) : 0;
        let currentStep = 1;

        const removeTeams = () => {
          if (currentStep > maxElimOrder) {
            console.log('Animation complete');
            setIsAnimating(false);
            setCurrentElimOrder(0);
            return;
          }

          setCurrentElimOrder(currentStep);
          console.log(`Removing teams at elim order ${currentStep}:`, teams.filter(t => t['elim order'] === currentStep).map(t => t.team));
          currentStep++;
          if (isAnimating) setTimeout(removeTeams, 1000);
        };

        teams.forEach(team => {
          const logo = document.querySelector(`.team-logo[data-team="${team.team}"]`);
          if (logo) logo.style.opacity = '1';
        });
        setTimeout(removeTeams, 1000);
      };

      const stepForward = () => {
        if (!selectedSeason || isAnimating) return;
        const teams = eliminationData[selectedSeason]
          ? eliminationData[selectedSeason].sort((a, b) => a['elim order'] - b['elim order'])
          : [];
        const maxElimOrder = teams.length ? Math.max(...teams.map(t => t['elim order'])) : 0;
        if (currentElimOrder >= maxElimOrder) return;

        const nextStep = currentElimOrder + 1;
        setCurrentElimOrder(nextStep);
        console.log(`Stepping forward to elim order ${nextStep}:`, teams.filter(t => t['elim order'] === nextStep).map(t => t.team));
      };

      const stepBack = () => {
        if (!selectedSeason || isAnimating) return;
        if (currentElimOrder <= 0) return;

        const prevStep = currentElimOrder - 1;
        setCurrentElimOrder(prevStep);
        console.log(`Stepping back to elim order ${prevStep}`);
        const teams = eliminationData[selectedSeason] || [];
        teams.forEach(team => {
          const logo = document.querySelector(`.team-logo[data-team="${team.team}"]`);
          if (logo) logo.style.opacity = team['elim order'] <= prevStep ? '0' : '1';
        });
      };

      const resetAnimation = () => {
        console.log('Resetting animation for season:', selectedSeason);
        setIsAnimating(false);
        setCurrentElimOrder(0);
        const teams = eliminationData[selectedSeason] || [];
        teams.forEach(team => {
          const logo = document.querySelector(`.team-logo[data-team="${team.team}"]`);
          if (logo) logo.style.opacity = '1';
        });
      };

      const renderTeams = () => {
        if (!selectedSeason || !eliminationData[selectedSeason]) {
          console.log('No season selected or data missing for:', selectedSeason);
          return <div className="team-container"></div>;
        }

        console.log('Rendering teams for season:', selectedSeason, 'with teams:', eliminationData[selectedSeason].map(t => t.team));
        return (
          <div className="team-container">
            {eliminationData[selectedSeason].map(team => {
              const coords = teamCoordinates[team.team];
              if (!coords) {
                console.warn(`No coordinates for team ${team.team} in season ${selectedSeason}`);
                return null;
              }

              const { x, y } = project(coords.lat, coords.lon);
              const teamAbbr = team.team;
              console.log(`Attempting to load logo: /logos/NHL${selectedSeason}/${teamAbbr}.png at x: ${x}, y: ${y}`);
              return (
                <div
                  key={teamAbbr}
                  className="team-logo"
                  data-team={teamAbbr}
                  style={{ 
                    left: `${x - 30}px`, 
                    top: `${y - 30}px`, 
                    opacity: team['elim order'] <= currentElimOrder ? '0' : '1',
                    display: (x < 0 || x > 1200 || y < 0 || y > 900) ? 'none' : 'block'
                  }}
                >
                  <img
                    src={`logos/NHL${selectedSeason}/${teamAbbr}.png`}
                    alt={teamAbbr}
                    onError={(e) => {
                      console.error(`Failed to load logo for ${teamAbbr} in season ${selectedSeason} at /logos/NHL${selectedSeason}/${teamAbbr}.png`);
                      e.target.style.display = 'none';
                    }}
                    onLoad={() => console.log(`Successfully loaded logo for ${teamAbbr} in season ${selectedSeason} at /logos/NHL${selectedSeason}/${teamAbbr}.png`)}
                  />
                </div>
              );
            })}
          </div>
        );
      };

      const seasonsRange = Array.from({ length: 2025 - 1967 + 1 }, (_, i) => (1967 + i).toString());

      console.log('Rendering component, eliminationData keys:', Object.keys(eliminationData));

      return (
        <ErrorBoundary>
          <div className="container mx-auto p-4">
            <h1 className="text-3xl font-bold text-center mb-4">NHL Playoff Elimination Tracker</h1>
            <p className="text-center mb-2">Current Season: {selectedSeason || '2025'}</p>
            {isLoading && <div className="loading-message">Loading data...</div>}
            {error && <div className="error-message">Error: {error}</div>}
            <div className="controls flex justify-center mb-4 space-x-2">
              <select
                value={selectedSeason}
                onChange={handleSeasonChange}
                className="p-2 border rounded min-w-[150px] bg-white z-[1000] visible"
                disabled={isAnimating || isLoading}
              >
                <option value="">Select a Season</option>
                {(Object.keys(eliminationData).length > 0
                  ? Object.keys(eliminationData)
                  : seasonsRange
                )
                  .sort((a, b) => b - a)
                  .map(season => (
                    <option key={season} value={season}>
                      {season}
                    </option>
                  ))}
              </select>
              <button
                onClick={startAnimation}
                className={`px-4 py-2 rounded text-white ${selectedSeason && !isAnimating && !isLoading ? 'bg-blue-500 hover:bg-blue-600' : 'bg-gray-400 cursor-not-allowed'}`}
                disabled={!selectedSeason || isAnimating || isLoading}
              >
                Play Animation
              </button>
              <button
                onClick={stepBack}
                className={`px-4 py-2 rounded text-white ${selectedSeason && !isAnimating && !isLoading ? 'bg-blue-500 hover:bg-blue-600' : 'bg-gray-400 cursor-not-allowed'}`}
                disabled={!selectedSeason || isAnimating || isLoading || currentElimOrder <= 0}
              >
                Step Back
              </button>
              <button
                onClick={stepForward}
                className={`px-4 py-2 rounded text-white ${selectedSeason && !isAnimating && !isLoading ? 'bg-blue-500 hover:bg-blue-600' : 'bg-gray-400 cursor-not-allowed'}`}
                disabled={!selectedSeason || isAnimating || isLoading}
              >
                Step Forward
              </button>
              <button
                onClick={resetAnimation}
                className={`px-4 py-2 rounded text-white ${selectedSeason && !isLoading ? 'bg-blue-500 hover:bg-blue-600' : 'bg-gray-400 cursor-not-allowed'}`}
                disabled={!selectedSeason || isLoading}
              >
                Reset
              </button>
            </div>
            <div className="team-container">
              {renderTeams()}
            </div>
          </div>
        </ErrorBoundary>
      );
    }

    if (typeof React === 'undefined' || typeof ReactDOM === 'undefined') {
      console.error('React or ReactDOM failed to load');
      document.getElementById('root').innerHTML = '<div className="error-message">Error: React failed to load. Check script sources.</div>';
    } else {
      console.log('Rendering React component...');
      ReactDOM.render(<App />, document.getElementById('root'));
    }
  </script>
</body>
</html>